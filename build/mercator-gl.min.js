(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MercatorGL"] = factory();
	else
		root["MercatorGL"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/mercator-gl.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/mercator-gl.js":
/*!****************************!*\
  !*** ./src/mercator-gl.js ***!
  \****************************/
/*! exports provided: highPrecisionLngLat, injectMercatorGLSL, allocateMercatorUniforms, updateMercatorUniforms, pixelsPerMeter, pixelsPerDegree, lngLatToWorld, worldToClip, lngLatToClip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "highPrecisionLngLat", function() { return highPrecisionLngLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "injectMercatorGLSL", function() { return injectMercatorGLSL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allocateMercatorUniforms", function() { return allocateMercatorUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateMercatorUniforms", function() { return updateMercatorUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pixelsPerMeter", function() { return pixelsPerMeter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pixelsPerDegree", function() { return pixelsPerDegree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lngLatToWorld", function() { return lngLatToWorld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "worldToClip", function() { return worldToClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lngLatToClip", function() { return lngLatToClip; });
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2019 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////

// GLSL projection code from deck.gl https://github.com/uber/deck.gl
// Used under MIT licence

// transformMat4 rom gl-matrix https://github.com/toji/gl-matrix/blob/master/src/vec4.js
// Used under MIT licence

const PI = Math.PI;
const PI_4 = PI / 4;
const DEGREES_TO_RADIANS = PI / 180;
const TILE_SIZE = 512;
const EARTH_CIRCUMFERENCE = 40.03e6;

const PROJECTION_GLSL = `
#define MERCATOR_GL_TILE_SIZE 512.0
#define MERCATOR_GL_PI 3.1415926536
#define MERCATOR_GL_WORLD_SCALE (MERCATOR_GL_TILE_SIZE / (MERCATOR_GL_PI * 2.0))
#define MERCATOR_GL_OFFSET_THRESHOLD 4096.0

uniform vec2 mercator_gl_lngLatCenter;
uniform vec3 mercator_gl_angleDerivatives;
uniform float mercator_gl_scale;
uniform vec4 mercator_gl_clipCenter;
uniform mat4 mercator_gl_viewProjectionMatrix;

vec4 mercator_gl_lngLatToWorld(vec3 lngLatElevation, vec2 lngLatPrecision) {
    vec3 mercatorPosition;
    if (mercator_gl_scale < MERCATOR_GL_OFFSET_THRESHOLD) {
        mercatorPosition.xy = vec2(
            (radians(lngLatElevation.x) + MERCATOR_GL_PI) * MERCATOR_GL_WORLD_SCALE,
            (MERCATOR_GL_PI - log(tan(MERCATOR_GL_PI * 0.25 + radians(lngLatElevation.y) * 0.5))) * MERCATOR_GL_WORLD_SCALE
        ) * mercator_gl_scale;
        mercatorPosition.z = lngLatElevation.z;
    } else {
        mercatorPosition.xy = (lngLatElevation.xy - mercator_gl_lngLatCenter) + lngLatPrecision;
        float dy = mercatorPosition.y;
        mercatorPosition = vec3(
            mercatorPosition.x * mercator_gl_angleDerivatives.x,
            -mercatorPosition.y * (mercator_gl_angleDerivatives.y - dy * mercator_gl_angleDerivatives.z),
            lngLatElevation.z
        );
    }

    return vec4(mercatorPosition, 1.0);
}

vec4 mercator_gl_lngLatToWorld(vec3 lngLatElevation) {
    return mercator_gl_lngLatToWorld(lngLatElevation, vec2(0.0));
}

vec4 mercator_gl_lngLatToWorld(vec2 lngLat, vec2 lngLatPrecision) {
    return mercator_gl_lngLatToWorld(vec3(lngLat, 0.0), lngLatPrecision);
}

vec4 mercator_gl_lngLatToWorld(vec2 lngLat) {
    return mercator_gl_lngLatToWorld(vec3(lngLat, 0.0));
}

vec4 mercator_gl_worldToClip(vec4 worldPosition) {
    if (mercator_gl_scale >= MERCATOR_GL_OFFSET_THRESHOLD) {
        worldPosition.w = 0.0;
    }
    vec4 clipPosition = mercator_gl_viewProjectionMatrix * worldPosition;
    if (mercator_gl_scale >= MERCATOR_GL_OFFSET_THRESHOLD) {
        clipPosition += mercator_gl_clipCenter;
    }

    return clipPosition;
}

vec4 mercator_gl_lngLatToClip(vec3 lngLatElevation, vec2 lngLatPrecision) {
    return mercator_gl_worldToClip(mercator_gl_lngLatToWorld(lngLatElevation, lngLatPrecision));
}

vec4 mercator_gl_lngLatToClip(vec3 lngLatElevation) {
    return mercator_gl_lngLatToClip(lngLatElevation, vec2(0.0));
}

vec4 mercator_gl_lngLatToClip(vec2 lngLat, vec2 lngLatPrecision) {
    return mercator_gl_lngLatToClip(vec3(lngLat, 0.0), lngLatPrecision);
}

vec4 mercator_gl_lngLatToClip(vec2 lngLat) {
    return mercator_gl_lngLatToClip(vec3(lngLat, 0.0));
}

`;

// High-precision for intermediate calculations
let tempCenter64 = new Float64Array(4);

// Low-precision for uniforms and to avoid instability
let lngLat32 = new Float32Array(2);

function highPrecisionLngLat(lngLat, offset = 0, stride = 2) {
    let numElements = Math.ceil((lngLat.length - offset) / stride);
    let precisionData = new Float32Array(numElements * 2);
    for (let i = 0; i < numElements; ++i) {
        let lli = offset + i * stride;
        let pi = i * 2;

        precisionData[pi]     = lngLat[lli]     - Math.fround(lngLat[lli]);
        precisionData[pi + 1] = lngLat[lli + 1] - Math.fround(lngLat[lli + 1]);
    }

    return precisionData;
}

function injectMercatorGLSL(vsSource) {
    let versionMatch = vsSource.match(/#version \d+(\s+es)?\s*\n/);
    let versionLine = versionMatch ? versionMatch[0] : "";

    return vsSource.replace(versionLine, versionLine + PROJECTION_GLSL);
}

function allocateMercatorUniforms(uniforms = {}) {
    uniforms.mercator_gl_lngLatCenter = new Float32Array(2);
    uniforms.mercator_gl_angleDerivatives = new Float32Array(3);
    uniforms.mercator_gl_clipCenter = new Float32Array(4);
    uniforms.mercator_gl_viewProjectionMatrix = new Float32Array(16);
    uniforms.mercator_gl_scale = 0;

    return uniforms;
}

function updateMercatorUniforms(uniforms, lngLat, zoom, viewProjectionMatrix) {
    let longitude = lngLat[0];
    let latitude = lngLat[1];

    uniforms.mercator_gl_scale = Math.pow(2, zoom);

    uniforms.mercator_gl_lngLatCenter[0] = longitude;
    uniforms.mercator_gl_lngLatCenter[1] = latitude;

    let latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
    let latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    angleDerivatives(uniforms.mercator_gl_angleDerivatives, latitude, zoom, latCosine, latCosine2);

    lngLat32[0] = longitude;
    lngLat32[1] = latitude;
    lngLatToClip(uniforms.mercator_gl_clipCenter, lngLat32, zoom, viewProjectionMatrix);

    uniforms.mercator_gl_viewProjectionMatrix.set(viewProjectionMatrix);
 
    return uniforms;
}

function pixelsPerMeter(latitude, zoom, latCosine = Math.cos(latitude * DEGREES_TO_RADIANS)) {
    let scale = Math.pow(2, zoom);
    
    // Number of pixels occupied by one meter around current lat/lon
    return scale * TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}

function pixelsPerDegree(out, latitude, zoom, latCosine = Math.cos(latitude * DEGREES_TO_RADIANS)) {
    let scale = Math.pow(2, zoom);
    
    // Number of pixels occupied by one degree around current lat/lon
    out[0] = scale * TILE_SIZE / 360;
    out[1] = out[0] / latCosine;

    return out;
}

function lngLatToWorld(out, lngLat, zoom) {
    let longitude = lngLat[0];
    let latitude = lngLat[1];
    let scale = Math.pow(2, zoom);

    let lambda2 = longitude * DEGREES_TO_RADIANS;
    let phi2 = latitude * DEGREES_TO_RADIANS;
    let x = scale * TILE_SIZE * (lambda2 + PI) / (2 * PI);
    let y = scale * TILE_SIZE * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);

    out[0] = x;
    out[1] = y;
    out[2] = 0;
    out[3] = 1;

    return out;
}

function worldToClip(out, worldPosition, viewProjectionMatrix) {
    transformMat4(out, worldPosition, viewProjectionMatrix);

    return out;
}

function lngLatToClip(out, lngLat, zoom, viewProjectionMatrix) {
    lngLatToWorld(tempCenter64, lngLat, zoom);
    worldToClip(out, tempCenter64, viewProjectionMatrix);

    return out;
}

function angleDerivatives(out, latitude, zoom, latCosine, latCosine2) {
    pixelsPerDegree(out, latitude, zoom, latCosine);
    out[2] = out[0] * latCosine2 / 2;
}

function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NZXJjYXRvckdML3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9NZXJjYXRvckdML3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL01lcmNhdG9yR0wvLi9zcmMvbWVyY2F0b3ItZ2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVPLCtDQUErQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJtZXJjYXRvci1nbC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJNZXJjYXRvckdMXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIk1lcmNhdG9yR0xcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL21lcmNhdG9yLWdsLmpzXCIpO1xuIiwiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAxOSBUYXJlayBTaGVyaWZcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4vLyB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4vLyB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4vLyB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuLy8gdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuLy8gc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXG4vLyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1Jcbi8vIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxuLy8gSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbi8vIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBHTFNMIHByb2plY3Rpb24gY29kZSBmcm9tIGRlY2suZ2wgaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbFxuLy8gVXNlZCB1bmRlciBNSVQgbGljZW5jZVxuXG4vLyB0cmFuc2Zvcm1NYXQ0IHJvbSBnbC1tYXRyaXggaHR0cHM6Ly9naXRodWIuY29tL3RvamkvZ2wtbWF0cml4L2Jsb2IvbWFzdGVyL3NyYy92ZWM0LmpzXG4vLyBVc2VkIHVuZGVyIE1JVCBsaWNlbmNlXG5cbmNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFBJXzQgPSBQSSAvIDQ7XG5jb25zdCBERUdSRUVTX1RPX1JBRElBTlMgPSBQSSAvIDE4MDtcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbmNvbnN0IEVBUlRIX0NJUkNVTUZFUkVOQ0UgPSA0MC4wM2U2O1xuXG5jb25zdCBQUk9KRUNUSU9OX0dMU0wgPSBgXG4jZGVmaW5lIE1FUkNBVE9SX0dMX1RJTEVfU0laRSA1MTIuMFxuI2RlZmluZSBNRVJDQVRPUl9HTF9QSSAzLjE0MTU5MjY1MzZcbiNkZWZpbmUgTUVSQ0FUT1JfR0xfV09STERfU0NBTEUgKE1FUkNBVE9SX0dMX1RJTEVfU0laRSAvIChNRVJDQVRPUl9HTF9QSSAqIDIuMCkpXG4jZGVmaW5lIE1FUkNBVE9SX0dMX09GRlNFVF9USFJFU0hPTEQgNDA5Ni4wXG5cbnVuaWZvcm0gdmVjMiBtZXJjYXRvcl9nbF9sbmdMYXRDZW50ZXI7XG51bmlmb3JtIHZlYzMgbWVyY2F0b3JfZ2xfYW5nbGVEZXJpdmF0aXZlcztcbnVuaWZvcm0gZmxvYXQgbWVyY2F0b3JfZ2xfc2NhbGU7XG51bmlmb3JtIHZlYzQgbWVyY2F0b3JfZ2xfY2xpcENlbnRlcjtcbnVuaWZvcm0gbWF0NCBtZXJjYXRvcl9nbF92aWV3UHJvamVjdGlvbk1hdHJpeDtcblxudmVjNCBtZXJjYXRvcl9nbF9sbmdMYXRUb1dvcmxkKHZlYzMgbG5nTGF0RWxldmF0aW9uLCB2ZWMyIGxuZ0xhdFByZWNpc2lvbikge1xuICAgIHZlYzMgbWVyY2F0b3JQb3NpdGlvbjtcbiAgICBpZiAobWVyY2F0b3JfZ2xfc2NhbGUgPCBNRVJDQVRPUl9HTF9PRkZTRVRfVEhSRVNIT0xEKSB7XG4gICAgICAgIG1lcmNhdG9yUG9zaXRpb24ueHkgPSB2ZWMyKFxuICAgICAgICAgICAgKHJhZGlhbnMobG5nTGF0RWxldmF0aW9uLngpICsgTUVSQ0FUT1JfR0xfUEkpICogTUVSQ0FUT1JfR0xfV09STERfU0NBTEUsXG4gICAgICAgICAgICAoTUVSQ0FUT1JfR0xfUEkgLSBsb2codGFuKE1FUkNBVE9SX0dMX1BJICogMC4yNSArIHJhZGlhbnMobG5nTGF0RWxldmF0aW9uLnkpICogMC41KSkpICogTUVSQ0FUT1JfR0xfV09STERfU0NBTEVcbiAgICAgICAgKSAqIG1lcmNhdG9yX2dsX3NjYWxlO1xuICAgICAgICBtZXJjYXRvclBvc2l0aW9uLnogPSBsbmdMYXRFbGV2YXRpb24uejtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtZXJjYXRvclBvc2l0aW9uLnh5ID0gKGxuZ0xhdEVsZXZhdGlvbi54eSAtIG1lcmNhdG9yX2dsX2xuZ0xhdENlbnRlcikgKyBsbmdMYXRQcmVjaXNpb247XG4gICAgICAgIGZsb2F0IGR5ID0gbWVyY2F0b3JQb3NpdGlvbi55O1xuICAgICAgICBtZXJjYXRvclBvc2l0aW9uID0gdmVjMyhcbiAgICAgICAgICAgIG1lcmNhdG9yUG9zaXRpb24ueCAqIG1lcmNhdG9yX2dsX2FuZ2xlRGVyaXZhdGl2ZXMueCxcbiAgICAgICAgICAgIC1tZXJjYXRvclBvc2l0aW9uLnkgKiAobWVyY2F0b3JfZ2xfYW5nbGVEZXJpdmF0aXZlcy55IC0gZHkgKiBtZXJjYXRvcl9nbF9hbmdsZURlcml2YXRpdmVzLnopLFxuICAgICAgICAgICAgbG5nTGF0RWxldmF0aW9uLnpcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVjNChtZXJjYXRvclBvc2l0aW9uLCAxLjApO1xufVxuXG52ZWM0IG1lcmNhdG9yX2dsX2xuZ0xhdFRvV29ybGQodmVjMyBsbmdMYXRFbGV2YXRpb24pIHtcbiAgICByZXR1cm4gbWVyY2F0b3JfZ2xfbG5nTGF0VG9Xb3JsZChsbmdMYXRFbGV2YXRpb24sIHZlYzIoMC4wKSk7XG59XG5cbnZlYzQgbWVyY2F0b3JfZ2xfbG5nTGF0VG9Xb3JsZCh2ZWMyIGxuZ0xhdCwgdmVjMiBsbmdMYXRQcmVjaXNpb24pIHtcbiAgICByZXR1cm4gbWVyY2F0b3JfZ2xfbG5nTGF0VG9Xb3JsZCh2ZWMzKGxuZ0xhdCwgMC4wKSwgbG5nTGF0UHJlY2lzaW9uKTtcbn1cblxudmVjNCBtZXJjYXRvcl9nbF9sbmdMYXRUb1dvcmxkKHZlYzIgbG5nTGF0KSB7XG4gICAgcmV0dXJuIG1lcmNhdG9yX2dsX2xuZ0xhdFRvV29ybGQodmVjMyhsbmdMYXQsIDAuMCkpO1xufVxuXG52ZWM0IG1lcmNhdG9yX2dsX3dvcmxkVG9DbGlwKHZlYzQgd29ybGRQb3NpdGlvbikge1xuICAgIGlmIChtZXJjYXRvcl9nbF9zY2FsZSA+PSBNRVJDQVRPUl9HTF9PRkZTRVRfVEhSRVNIT0xEKSB7XG4gICAgICAgIHdvcmxkUG9zaXRpb24udyA9IDAuMDtcbiAgICB9XG4gICAgdmVjNCBjbGlwUG9zaXRpb24gPSBtZXJjYXRvcl9nbF92aWV3UHJvamVjdGlvbk1hdHJpeCAqIHdvcmxkUG9zaXRpb247XG4gICAgaWYgKG1lcmNhdG9yX2dsX3NjYWxlID49IE1FUkNBVE9SX0dMX09GRlNFVF9USFJFU0hPTEQpIHtcbiAgICAgICAgY2xpcFBvc2l0aW9uICs9IG1lcmNhdG9yX2dsX2NsaXBDZW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBQb3NpdGlvbjtcbn1cblxudmVjNCBtZXJjYXRvcl9nbF9sbmdMYXRUb0NsaXAodmVjMyBsbmdMYXRFbGV2YXRpb24sIHZlYzIgbG5nTGF0UHJlY2lzaW9uKSB7XG4gICAgcmV0dXJuIG1lcmNhdG9yX2dsX3dvcmxkVG9DbGlwKG1lcmNhdG9yX2dsX2xuZ0xhdFRvV29ybGQobG5nTGF0RWxldmF0aW9uLCBsbmdMYXRQcmVjaXNpb24pKTtcbn1cblxudmVjNCBtZXJjYXRvcl9nbF9sbmdMYXRUb0NsaXAodmVjMyBsbmdMYXRFbGV2YXRpb24pIHtcbiAgICByZXR1cm4gbWVyY2F0b3JfZ2xfbG5nTGF0VG9DbGlwKGxuZ0xhdEVsZXZhdGlvbiwgdmVjMigwLjApKTtcbn1cblxudmVjNCBtZXJjYXRvcl9nbF9sbmdMYXRUb0NsaXAodmVjMiBsbmdMYXQsIHZlYzIgbG5nTGF0UHJlY2lzaW9uKSB7XG4gICAgcmV0dXJuIG1lcmNhdG9yX2dsX2xuZ0xhdFRvQ2xpcCh2ZWMzKGxuZ0xhdCwgMC4wKSwgbG5nTGF0UHJlY2lzaW9uKTtcbn1cblxudmVjNCBtZXJjYXRvcl9nbF9sbmdMYXRUb0NsaXAodmVjMiBsbmdMYXQpIHtcbiAgICByZXR1cm4gbWVyY2F0b3JfZ2xfbG5nTGF0VG9DbGlwKHZlYzMobG5nTGF0LCAwLjApKTtcbn1cblxuYDtcblxuLy8gSGlnaC1wcmVjaXNpb24gZm9yIGludGVybWVkaWF0ZSBjYWxjdWxhdGlvbnNcbmxldCB0ZW1wQ2VudGVyNjQgPSBuZXcgRmxvYXQ2NEFycmF5KDQpO1xuXG4vLyBMb3ctcHJlY2lzaW9uIGZvciB1bmlmb3JtcyBhbmQgdG8gYXZvaWQgaW5zdGFiaWxpdHlcbmxldCBsbmdMYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbmV4cG9ydCBmdW5jdGlvbiBoaWdoUHJlY2lzaW9uTG5nTGF0KGxuZ0xhdCwgb2Zmc2V0ID0gMCwgc3RyaWRlID0gMikge1xuICAgIGxldCBudW1FbGVtZW50cyA9IE1hdGguY2VpbCgobG5nTGF0Lmxlbmd0aCAtIG9mZnNldCkgLyBzdHJpZGUpO1xuICAgIGxldCBwcmVjaXNpb25EYXRhID0gbmV3IEZsb2F0MzJBcnJheShudW1FbGVtZW50cyAqIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7ICsraSkge1xuICAgICAgICBsZXQgbGxpID0gb2Zmc2V0ICsgaSAqIHN0cmlkZTtcbiAgICAgICAgbGV0IHBpID0gaSAqIDI7XG5cbiAgICAgICAgcHJlY2lzaW9uRGF0YVtwaV0gICAgID0gbG5nTGF0W2xsaV0gICAgIC0gTWF0aC5mcm91bmQobG5nTGF0W2xsaV0pO1xuICAgICAgICBwcmVjaXNpb25EYXRhW3BpICsgMV0gPSBsbmdMYXRbbGxpICsgMV0gLSBNYXRoLmZyb3VuZChsbmdMYXRbbGxpICsgMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVjaXNpb25EYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0TWVyY2F0b3JHTFNMKHZzU291cmNlKSB7XG4gICAgbGV0IHZlcnNpb25NYXRjaCA9IHZzU291cmNlLm1hdGNoKC8jdmVyc2lvbiBcXGQrKFxccytlcyk/XFxzKlxcbi8pO1xuICAgIGxldCB2ZXJzaW9uTGluZSA9IHZlcnNpb25NYXRjaCA/IHZlcnNpb25NYXRjaFswXSA6IFwiXCI7XG5cbiAgICByZXR1cm4gdnNTb3VyY2UucmVwbGFjZSh2ZXJzaW9uTGluZSwgdmVyc2lvbkxpbmUgKyBQUk9KRUNUSU9OX0dMU0wpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsb2NhdGVNZXJjYXRvclVuaWZvcm1zKHVuaWZvcm1zID0ge30pIHtcbiAgICB1bmlmb3Jtcy5tZXJjYXRvcl9nbF9sbmdMYXRDZW50ZXIgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIHVuaWZvcm1zLm1lcmNhdG9yX2dsX2FuZ2xlRGVyaXZhdGl2ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIHVuaWZvcm1zLm1lcmNhdG9yX2dsX2NsaXBDZW50ZXIgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHVuaWZvcm1zLm1lcmNhdG9yX2dsX3ZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgdW5pZm9ybXMubWVyY2F0b3JfZ2xfc2NhbGUgPSAwO1xuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWVyY2F0b3JVbmlmb3Jtcyh1bmlmb3JtcywgbG5nTGF0LCB6b29tLCB2aWV3UHJvamVjdGlvbk1hdHJpeCkge1xuICAgIGxldCBsb25naXR1ZGUgPSBsbmdMYXRbMF07XG4gICAgbGV0IGxhdGl0dWRlID0gbG5nTGF0WzFdO1xuXG4gICAgdW5pZm9ybXMubWVyY2F0b3JfZ2xfc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcblxuICAgIHVuaWZvcm1zLm1lcmNhdG9yX2dsX2xuZ0xhdENlbnRlclswXSA9IGxvbmdpdHVkZTtcbiAgICB1bmlmb3Jtcy5tZXJjYXRvcl9nbF9sbmdMYXRDZW50ZXJbMV0gPSBsYXRpdHVkZTtcblxuICAgIGxldCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gICAgbGV0IGxhdENvc2luZTIgPSBERUdSRUVTX1RPX1JBRElBTlMgKiBNYXRoLnRhbihsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUykgLyBsYXRDb3NpbmU7XG4gICAgYW5nbGVEZXJpdmF0aXZlcyh1bmlmb3Jtcy5tZXJjYXRvcl9nbF9hbmdsZURlcml2YXRpdmVzLCBsYXRpdHVkZSwgem9vbSwgbGF0Q29zaW5lLCBsYXRDb3NpbmUyKTtcblxuICAgIGxuZ0xhdDMyWzBdID0gbG9uZ2l0dWRlO1xuICAgIGxuZ0xhdDMyWzFdID0gbGF0aXR1ZGU7XG4gICAgbG5nTGF0VG9DbGlwKHVuaWZvcm1zLm1lcmNhdG9yX2dsX2NsaXBDZW50ZXIsIGxuZ0xhdDMyLCB6b29tLCB2aWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICB1bmlmb3Jtcy5tZXJjYXRvcl9nbF92aWV3UHJvamVjdGlvbk1hdHJpeC5zZXQodmlld1Byb2plY3Rpb25NYXRyaXgpO1xuIFxuICAgIHJldHVybiB1bmlmb3Jtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpeGVsc1Blck1ldGVyKGxhdGl0dWRlLCB6b29tLCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUykpIHtcbiAgICBsZXQgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICBcbiAgICAvLyBOdW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBtZXRlciBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gICAgcmV0dXJuIHNjYWxlICogVElMRV9TSVpFIC8gRUFSVEhfQ0lSQ1VNRkVSRU5DRSAvIGxhdENvc2luZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpeGVsc1BlckRlZ3JlZShvdXQsIGxhdGl0dWRlLCB6b29tLCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUykpIHtcbiAgICBsZXQgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICBcbiAgICAvLyBOdW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICAgIG91dFswXSA9IHNjYWxlICogVElMRV9TSVpFIC8gMzYwO1xuICAgIG91dFsxXSA9IG91dFswXSAvIGxhdENvc2luZTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsbmdMYXRUb1dvcmxkKG91dCwgbG5nTGF0LCB6b29tKSB7XG4gICAgbGV0IGxvbmdpdHVkZSA9IGxuZ0xhdFswXTtcbiAgICBsZXQgbGF0aXR1ZGUgPSBsbmdMYXRbMV07XG4gICAgbGV0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG5cbiAgICBsZXQgbGFtYmRhMiA9IGxvbmdpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgICBsZXQgcGhpMiA9IGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TO1xuICAgIGxldCB4ID0gc2NhbGUgKiBUSUxFX1NJWkUgKiAobGFtYmRhMiArIFBJKSAvICgyICogUEkpO1xuICAgIGxldCB5ID0gc2NhbGUgKiBUSUxFX1NJWkUgKiAoUEkgLSBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKSAvICgyICogUEkpO1xuXG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3b3JsZFRvQ2xpcChvdXQsIHdvcmxkUG9zaXRpb24sIHZpZXdQcm9qZWN0aW9uTWF0cml4KSB7XG4gICAgdHJhbnNmb3JtTWF0NChvdXQsIHdvcmxkUG9zaXRpb24sIHZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsbmdMYXRUb0NsaXAob3V0LCBsbmdMYXQsIHpvb20sIHZpZXdQcm9qZWN0aW9uTWF0cml4KSB7XG4gICAgbG5nTGF0VG9Xb3JsZCh0ZW1wQ2VudGVyNjQsIGxuZ0xhdCwgem9vbSk7XG4gICAgd29ybGRUb0NsaXAob3V0LCB0ZW1wQ2VudGVyNjQsIHZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGFuZ2xlRGVyaXZhdGl2ZXMob3V0LCBsYXRpdHVkZSwgem9vbSwgbGF0Q29zaW5lLCBsYXRDb3NpbmUyKSB7XG4gICAgcGl4ZWxzUGVyRGVncmVlKG91dCwgbGF0aXR1ZGUsIHpvb20sIGxhdENvc2luZSk7XG4gICAgb3V0WzJdID0gb3V0WzBdICogbGF0Q29zaW5lMiAvIDI7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCB3ID0gYVszXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gIHJldHVybiBvdXQ7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9