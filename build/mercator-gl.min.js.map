{"version":3,"sources":["webpack://MercatorGL/webpack/universalModuleDefinition","webpack://MercatorGL/webpack/bootstrap","webpack://MercatorGL/./src/mercator-gl.js","webpack://MercatorGL/./src/projection-glsl.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","PI","Math","PI_4","DEGREES_TO_RADIANS","tempCenter64","Float64Array","lngLat32","Float32Array","highPrecisionLngLat","lngLat","offset","stride","numElements","ceil","length","precisionData","lli","pi","fround","injectMercatorGLSL","vsSource","versionMatch","match","versionLine","replace","allocateMercatorUniforms","uniforms","mercator_gl_lngLatCenter","mercator_gl_angleDerivatives","mercator_gl_clipCenter","mercator_gl_viewProjectionMatrix","mercator_gl_scale","updateMercatorUniforms","zoom","viewProjectionMatrix","longitude","latitude","pow","out","latCosine","cos","latCosine2","tan","pixelsPerDegree","angleDerivatives","lngLatToClip","set","pixelsPerMeter","scale","lngLatToMercator","phi2","x","y","log","mercatorToClip","mercatorPosition","a","z","w","transformMat4"],"mappings":"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","file":"mercator-gl.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MercatorGL\"] = factory();\n\telse\n\t\troot[\"MercatorGL\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","///////////////////////////////////////////////////////////////////////////////////\n// The MIT License (MIT)\n//\n// Copyright (c) 2019 Tarek Sherif\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n///////////////////////////////////////////////////////////////////////////////////\n\n/**\n    @module JavaScript\n*/\n\n// GLSL projection code from deck.gl https://github.com/uber/deck.gl\n// Used under MIT licence\n\n// transformMat4 from gl-matrix https://github.com/toji/gl-matrix/blob/master/src/vec4.js\n// Used under MIT licence\n\nimport {PROJECTION_GLSL} from \"./projection-glsl.js\";\n\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst TILE_SIZE = 512;\nconst EARTH_CIRCUMFERENCE = 40.03e6;\n\n\n// High-precision for intermediate calculations\nlet tempCenter64 = new Float64Array(4);\n\n// Low-precision for uniforms and to avoid instability\nlet lngLat32 = new Float32Array(2);\n\n/**\n    Create a Float32Array containing the low-part of 64-bit floats. The\n    low parts can be passed to GLSL projection functions to improve numerical\n    stability.\n\n    @function\n    @param {Float32Array} lnglat Array containing longitude latitude data (assumed to be in adjacent elements).\n    @param {number} offset Offset of the first longitude value from the start of the array.\n    @param {number} stride Number of elements between each pair of longitude/latitude values.\n    @return {Float32Array} Array containing the low parts of input longitude/latitude data.\n*/\nexport function highPrecisionLngLat(lngLat, offset = 0, stride = 2) {\n    let numElements = Math.ceil((lngLat.length - offset) / stride);\n    let precisionData = new Float32Array(numElements * 2);\n    for (let i = 0; i < numElements; ++i) {\n        let lli = offset + i * stride;\n        let pi = i * 2;\n\n        precisionData[pi]     = lngLat[lli]     - Math.fround(lngLat[lli]);\n        precisionData[pi + 1] = lngLat[lli + 1] - Math.fround(lngLat[lli + 1]);\n    }\n\n    return precisionData;\n}\n\n/**\n    Inject MercatorGL projection functions in to GLSL vertex shader source string.\n\n    @function\n    @param {string} vsSource Vertex shader source code. Can be GLSL 1 or 3.\n    @return {string} Source code with the projection functions injected.\n*/\nexport function injectMercatorGLSL(vsSource) {\n    let versionMatch = vsSource.match(/#version \\d+(\\s+es)?\\s*\\n/);\n    let versionLine = versionMatch ? versionMatch[0] : \"\";\n\n    return vsSource.replace(versionLine, versionLine + PROJECTION_GLSL);\n}\n\n/**\n    Allocate arrays to store projection uniform values. Will add uniforms\n    to existing object, if provided.\n\n    @function\n    @param {object} [uniforms] Optional object containing existing uniforms.\n    @return {object} Object containing projection uniforms.\n*/\nexport function allocateMercatorUniforms(uniforms = {}) {\n    uniforms.mercator_gl_lngLatCenter = new Float32Array(2);\n    uniforms.mercator_gl_angleDerivatives = new Float32Array(3);\n    uniforms.mercator_gl_clipCenter = new Float32Array(4);\n    uniforms.mercator_gl_viewProjectionMatrix = new Float32Array(16);\n    uniforms.mercator_gl_scale = 0;\n\n    return uniforms;\n}\n\n/**\n    Update projection uniforms based on current mercator settings and provided\n    view-projection matrix. The view projection matrix is expected to project from\n    a 512x512x<elevation meters> mercator space to clip space.\n\n    @function\n    @param {object} uniforms Object containing existing uniforms.\n    @param {array} lngLat Current camera center as a 2-element longitude/latitude array.\n    @param {number} zoom Current mercator zoom level.\n    @param {array} viewProjectionMatrix 4x4 matrix to transform from mercator space to clip space.\n    @return {object} Object containing updated uniforms.\n*/\nexport function updateMercatorUniforms(uniforms, lngLat, zoom, viewProjectionMatrix) {\n    let longitude = lngLat[0];\n    let latitude = lngLat[1];\n\n    uniforms.mercator_gl_scale = Math.pow(2, zoom);\n\n    uniforms.mercator_gl_lngLatCenter[0] = longitude;\n    uniforms.mercator_gl_lngLatCenter[1] = latitude;\n\n    angleDerivatives(uniforms.mercator_gl_angleDerivatives, latitude, zoom);\n\n    lngLat32[0] = longitude;\n    lngLat32[1] = latitude;\n    lngLatToClip(uniforms.mercator_gl_clipCenter, lngLat32, zoom, viewProjectionMatrix);\n\n    uniforms.mercator_gl_viewProjectionMatrix.set(viewProjectionMatrix);\n \n    return uniforms;\n}\n\n/**\n    Mercator pixels/meter at the current latitude and zoom level (using 512x512 tile size).\n\n    @function\n    @param {number} latitude Current latitude of the camera center.\n    @param {number} zoom Current mercator zoom level.\n    @return {number} Number of pixels per meter.\n*/\nexport function pixelsPerMeter(latitude, zoom) {\n    let scale = Math.pow(2, zoom);\n    let latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n    \n    // Number of pixels occupied by one meter around current lat/lon\n    return scale * TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;\n}\n\n/**\n    Mercator pixels/degree of longitude and latitude at the current latitude and zoom level (using 512x512 tile size).\n\n    @function\n    @param {array} out Two-element array into which the results will be written.\n    @param {number} latitude Current latitude of the camera center.\n    @param {number} zoom Current mercator zoom level.\n    @return {array} The \"out\" array provided, containing the results.\n*/\nexport function pixelsPerDegree(out, latitude, zoom) {\n    let scale = Math.pow(2, zoom);\n    let latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n    \n    // Number of pixels occupied by one degree around current lat/lon\n    out[0] = scale * TILE_SIZE / 360;\n    out[1] = out[0] / latCosine;\n\n    return out;\n}\n\n/**\n    Transform a longitude/latitude point to a 4d homegeneous coordinate in Mercator space.\n\n    @function\n    @param {array} out 4-element array into which the results will be written.\n    @param {array} lngLat Longitude/latitude coordinate.\n    @param {number} zoom Current mercator zoom level.\n    @return {array} The \"out\" array provided, containing the results.\n*/\nexport function lngLatToMercator(out, lngLat, zoom) {\n    let longitude = lngLat[0];\n    let latitude = lngLat[1];\n    let scale = Math.pow(2, zoom);\n\n    let lambda2 = longitude * DEGREES_TO_RADIANS;\n    let phi2 = latitude * DEGREES_TO_RADIANS;\n    let x = scale * TILE_SIZE * (lambda2 + PI) / (2 * PI);\n    let y = scale * TILE_SIZE * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n\n    out[0] = x;\n    out[1] = y;\n    out[2] = 0;\n    out[3] = 1;\n\n    return out;\n}\n\n/**\n    Transform a homegeneous 4d representation of a mercator point on the plane\n    (x, y, 0, 1) to clip space.\n\n    @function\n    @param {array} out 4-element array into which the results will be written.\n    @param {array} mercatorPosition Homegeneous 4d coordinate on the mercator plane.\n    @param {array} viewProjectionMatrix 4x4 matrix to transform from mercator space to clip space.\n    @return {array} The \"out\" array provided, containing the results.\n*/\nexport function mercatorToClip(out, mercatorPosition, viewProjectionMatrix) {\n    transformMat4(out, mercatorPosition, viewProjectionMatrix);\n\n    return out;\n}\n\n/**\n    Transform a 2d longitude/latitude point to clip space to clip space.\n\n    @function\n    @param {array} out 4-element array into which the results will be written.\n    @param {array} lngLat Longitude/latitude coordinate.\n    @param {array} viewProjectionMatrix 4x4 matrix to transform from mercator space to clip space.\n    @return {array} The \"out\" array provided, containing the results.\n*/\nexport function lngLatToClip(out, lngLat, zoom, viewProjectionMatrix) {\n    lngLatToMercator(tempCenter64, lngLat, zoom);\n    mercatorToClip(out, tempCenter64, viewProjectionMatrix);\n\n    return out;\n}\n\nfunction angleDerivatives(out, latitude, zoom) {\n    let latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n    let latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n\n    pixelsPerDegree(out, latitude, zoom);\n    out[2] = out[0] * latCosine2 / 2;\n}\n\nfunction transformMat4(out, a, m) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    \n    return out;\n}\n","/**\n    @module GLSL\n*/\n\n/**\n    Project a longitude/latitude/elevation coordinate into mercator space.\n\n    @function mercator_gl_lngLatToMercator\n    @param {vec3} lngLatElevation Longitude/latitude/meter elevation coordinate.\n    @param {vec2} lngLatPrecision \"Low part\" of 64-bit longitude/latitude coordinates.\n    @return {vec4} Homegeneous representation of mercator position.\n*/\n\n/**\n    Project a longitude/latitude/elevation coordinate into mercator space without\n    enhanced precition. Equivalent to <code>mercator_gl_lngLatToMercator(lngLatElevation, vec2(0.0))</code>.\n\n    @function mercator_gl_lngLatToMercator\n    @param {vec3} lngLatElevation Longitude/latitude/meter elevation coordinate.\n    @return {vec4} Homegeneous representation of mercator position.\n*/\n\n/**\n    Project a longitude/latitude coordinate into mercator space. Equivalent\n    to <code>mercator_gl_lngLatToMercator(vec3(lngLat, 0.0), lngLatPrecision)</code>.\n\n    @function mercator_gl_lngLatToMercator\n    @param {vec2} lngLat Longitude/latitude coordinate.\n    @param {vec2} lngLatPrecision \"Low part\" of 64-bit longitude/latitude coordinates.\n    @return {vec4} Homegeneous representation of mercator position.\n*/\n\n/**\n    Project a longitude/latitude coordinate into mercator space without\n    enhanced precition. Equivalent to <code>mercator_gl_lngLatToMercator(vec3(lngLat, 0.0), vec2(0.0))</code>.\n\n    @function mercator_gl_lngLatToMercator\n    @param {vec2} lngLat Longitude/latitude coordinate.\n    @return {vec4} Homegeneous representation of mercator position.\n*/\n\n/**\n    Project a longitude/latitude coordinate into mercator space without\n    enhanced precition. Equivalent to <code>mercator_gl_lngLatToMercator(vec3(lngLat, 0.0), vec2(0.0))</code>.\n\n    @function mercator_gl_lngLatToMercator\n    @param {vec2} lngLat Longitude/latitude coordinate.\n    @return {vec4} Homegeneous representation of mercator position.\n*/\n\n/**\n    Project a homegeneous 4d mercator coordinate to clip space.\n\n    @function mercator_gl_mercatorToClip\n    @param {vec4} mercatorPosition x/y/<meter elevation/1 homegeneous mercator coordinate.\n    @return {vec4} Clip space coordinate (can be passed to <code>gl_Position</code>).\n*/\n\n/**\n    Project a longitude/latitude/elevation coordinate into clip space.\n\n    @function mercator_gl_lngLatToClip\n    @param {vec3} lngLatElevation Longitude/latitude/meter elevation coordinate.\n    @param {vec2} lngLatPrecision \"Low part\" of 64-bit longitude/latitude coordinates.\n    @return {vec4} Clip space coordinate (can be passed to <code>gl_Position</code>).\n*/\n\n/**\n    Project a longitude/latitude/elevation coordinate into clip space without\n    enhanced precition. Equivalent to <code>mercator_gl_lngLatToClip(lngLatElevation, vec2(0.0))</code>.\n\n    @function mercator_gl_lngLatToClip\n    @param {vec3} lngLatElevation Longitude/latitude/meter elevation coordinate.\n    @return {vec4} Clip space coordinate (can be passed to <code>gl_Position</code>).\n*/\n\n/**\n    Project a longitude/latitude coordinate into clip space. Equivalent\n    to <code>mercator_gl_lngLatToClip(vec3(lngLat, 0.0), lngLatPrecision)</code>.\n\n    @function mercator_gl_lngLatToClip\n    @param {vec2} lngLat Longitude/latitude coordinate.\n    @param {vec2} lngLatPrecision \"Low part\" of 64-bit longitude/latitude coordinates.\n    @return {vec4} Clip space coordinate (can be passed to <code>gl_Position</code>).\n*/\n\n/**\n    Project a longitude/latitude coordinate into clip space without\n    enhanced precition. Equivalent to <code>mercator_gl_lngLatToClip(vec3(lngLat, 0.0), vec2(0.0))</code>.\n\n    @function mercator_gl_lngLatToClip\n    @param {vec2} lngLat Longitude/latitude coordinate.\n    @return {vec4} Clip space coordinate (can be passed to <code>gl_Position</code>).\n*/\n\n/**\n    Project a longitude/latitude coordinate into clip space without\n    enhanced precition. Equivalent to <code>mercator_gl_lngLatToClip(vec3(lngLat, 0.0), vec2(0.0))</code>.\n\n    @function mercator_gl_lngLatToClip\n    @param {vec2} lngLat Longitude/latitude coordinate.\n    @return {vec4} Clip space coordinate (can be passed to <code>gl_Position</code>).\n*/\n\nexport const PROJECTION_GLSL = `\n#define MERCATOR_GL_TILE_SIZE 512.0\n#define MERCATOR_GL_PI 3.1415926536\n#define MERCATOR_GL_TILE_SCALE (MERCATOR_GL_TILE_SIZE / (MERCATOR_GL_PI * 2.0))\n#define MERCATOR_GL_OFFSET_THRESHOLD 4096.0\n\nuniform vec2 mercator_gl_lngLatCenter;\nuniform vec3 mercator_gl_angleDerivatives;\nuniform float mercator_gl_scale;\nuniform vec4 mercator_gl_clipCenter;\nuniform mat4 mercator_gl_viewProjectionMatrix;\n\nvec4 mercator_gl_lngLatToMercator(vec3 lngLatElevation, vec2 lngLatPrecision) {\n    vec3 mercatorPosition;\n    if (mercator_gl_scale < MERCATOR_GL_OFFSET_THRESHOLD) {\n        mercatorPosition.xy = vec2(\n            (radians(lngLatElevation.x) + MERCATOR_GL_PI) * MERCATOR_GL_TILE_SCALE,\n            (MERCATOR_GL_PI - log(tan(MERCATOR_GL_PI * 0.25 + radians(lngLatElevation.y) * 0.5))) * MERCATOR_GL_TILE_SCALE\n        ) * mercator_gl_scale;\n        mercatorPosition.z = lngLatElevation.z;\n    } else {\n        mercatorPosition.xy = (lngLatElevation.xy - mercator_gl_lngLatCenter) + lngLatPrecision;\n        float dy = mercatorPosition.y;\n        mercatorPosition = vec3(\n            mercatorPosition.x * mercator_gl_angleDerivatives.x,\n            -mercatorPosition.y * (mercator_gl_angleDerivatives.y - dy * mercator_gl_angleDerivatives.z),\n            lngLatElevation.z\n        );\n    }\n\n    return vec4(mercatorPosition, 1.0);\n}\n\nvec4 mercator_gl_lngLatToMercator(vec3 lngLatElevation) {\n    return mercator_gl_lngLatToMercator(lngLatElevation, vec2(0.0));\n}\n\nvec4 mercator_gl_lngLatToMercator(vec2 lngLat, vec2 lngLatPrecision) {\n    return mercator_gl_lngLatToMercator(vec3(lngLat, 0.0), lngLatPrecision);\n}\n\nvec4 mercator_gl_lngLatToMercator(vec2 lngLat) {\n    return mercator_gl_lngLatToMercator(vec3(lngLat, 0.0));\n}\n\nvec4 mercator_gl_mercatorToClip(vec4 mercatorPosition) {\n    if (mercator_gl_scale >= MERCATOR_GL_OFFSET_THRESHOLD) {\n        mercatorPosition.w = 0.0;\n    }\n    vec4 clipPosition = mercator_gl_viewProjectionMatrix * mercatorPosition;\n    if (mercator_gl_scale >= MERCATOR_GL_OFFSET_THRESHOLD) {\n        clipPosition += mercator_gl_clipCenter;\n    }\n\n    return clipPosition;\n}\n\nvec4 mercator_gl_lngLatToClip(vec3 lngLatElevation, vec2 lngLatPrecision) {\n    return mercator_gl_mercatorToClip(mercator_gl_lngLatToMercator(lngLatElevation, lngLatPrecision));\n}\n\nvec4 mercator_gl_lngLatToClip(vec3 lngLatElevation) {\n    return mercator_gl_lngLatToClip(lngLatElevation, vec2(0.0));\n}\n\nvec4 mercator_gl_lngLatToClip(vec2 lngLat, vec2 lngLatPrecision) {\n    return mercator_gl_lngLatToClip(vec3(lngLat, 0.0), lngLatPrecision);\n}\n\nvec4 mercator_gl_lngLatToClip(vec2 lngLat) {\n    return mercator_gl_lngLatToClip(vec3(lngLat, 0.0));\n}\n\n`;\n"],"sourceRoot":""}